#!/usr/bin/env python3
"""
Script de test pour la base de donn√©es MongoDB BreakIn Direct
Usage: python test_db.py
"""

import sys
import asyncio
import logging
from datetime import datetime
from pathlib import Path

# Ajouter le r√©pertoire parent au PYTHONPATH
sys.path.append(str(Path(__file__).parent.parent))

from app.config import connect_to_mongodb, get_database, close_mongodb_connection
from app.services.db import DatabaseService

# Configuration du logging pour le test
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class DatabaseTester:
    """
    Classe pour tester toutes les fonctionnalit√©s de la base de donn√©es
    """
    
    def __init__(self):
        self.db_service = DatabaseService()  # Initialiser directement
        self.test_data = {
            "user_id": None,
            "sprint_id": None,
            "feedback_id": None,
            "submission_id": None
        }
    
    async def setup(self):
        """Initialiser la connexion √† la base de donn√©es"""
        try:
            logger.info("üöÄ Initialisation des tests de base de donn√©es...")
            
            # Tester la connexion
            if not connect_to_mongodb():
                raise Exception("Impossible de se connecter √† MongoDB")
            
            logger.info("‚úÖ Service de base de donn√©es initialis√©")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'initialisation: {e}")
            return False
    
    async def test_user_operations(self):
        """Tester les op√©rations utilisateur"""
        logger.info("\nüß™ Test des op√©rations utilisateur...")
        
        try:
            # Cr√©er un utilisateur de test
            user_data = {
                "pseudonym": f"TestUser_{datetime.now().strftime('%H%M%S')}",
                "email": "test@breakin.dev",
                "skills": ["Python", "FastAPI", "MongoDB"],
                "experience_level": "intermediate",
                "profile": {
                    "bio": "D√©veloppeur test pour BreakIn Direct",
                    "github": "https://github.com/testuser"
                }
            }
            
            user_id = await self.db_service.create_user(user_data)
            if user_id:
                self.test_data["user_id"] = user_id
                logger.info(f"‚úÖ Utilisateur cr√©√© avec l'ID: {user_id}")
                
                # R√©cup√©rer l'utilisateur par pseudonyme
                user = await self.db_service.get_user_by_pseudonym(user_data["pseudonym"])
                if user:
                    logger.info(f"‚úÖ Utilisateur r√©cup√©r√©: {user['pseudonym']}")
                    
                    # Mettre √† jour l'utilisateur
                    update_success = await self.db_service.update_user(
                        user_id, 
                        {"skills": ["Python", "FastAPI", "MongoDB", "React"]}
                    )
                    if update_success:
                        logger.info("‚úÖ Utilisateur mis √† jour avec succ√®s")
                    else:
                        logger.error("‚ùå √âchec de la mise √† jour utilisateur")
                
                return True
            else:
                logger.error("‚ùå √âchec de la cr√©ation utilisateur")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur dans les tests utilisateur: {e}")
            return False
    
    async def test_sprint_operations(self):
        """Tester les op√©rations de sprint"""
        logger.info("\nüß™ Test des op√©rations de sprint...")
        
        try:
            # Cr√©er un sprint de test
            sprint_data = {
                "title": "Test E-commerce API",
                "description": "Construire une API REST pour un e-commerce",
                "difficulty": "intermediate",
                "duration_days": 3,
                "max_participants": 4,
                "technologies": ["Python", "FastAPI", "MongoDB"],
                "requirements": [
                    "API REST compl√®te",
                    "Tests unitaires",
                    "Documentation Swagger"
                ],
                "mentor": "AI_Mentor_001"
            }
            
            sprint_id = await self.db_service.create_sprint(sprint_data)
            if sprint_id:
                self.test_data["sprint_id"] = sprint_id
                logger.info(f"‚úÖ Sprint cr√©√© avec l'ID: {sprint_id}")
                
                # R√©cup√©rer le sprint
                sprint = await self.db_service.get_sprint(sprint_id)
                if sprint:
                    logger.info(f"‚úÖ Sprint r√©cup√©r√©: {sprint['title']}")
                    
                    # Rejoindre le sprint avec l'utilisateur test
                    if self.test_data["user_id"]:
                        user = await self.db_service.get_user_by_pseudonym(
                            f"TestUser_{datetime.now().strftime('%H%M%S')}"
                        )
                        if user:
                            join_success = await self.db_service.join_sprint(
                                sprint_id, 
                                user["pseudonym"]
                            )
                            if join_success:
                                logger.info("‚úÖ Utilisateur a rejoint le sprint")
                            else:
                                logger.error("‚ùå √âchec pour rejoindre le sprint")
                
                # Tester la r√©cup√©ration des sprints disponibles
                available_sprints = await self.db_service.get_available_sprints()
                logger.info(f"‚úÖ {len(available_sprints)} sprints disponibles trouv√©s")
                
                return True
            else:
                logger.error("‚ùå √âchec de la cr√©ation du sprint")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur dans les tests de sprint: {e}")
            return False
    
    async def test_submission_operations(self):
        """Tester les op√©rations de soumission"""
        logger.info("\nüß™ Test des op√©rations de soumission...")
        
        try:
            if not self.test_data["sprint_id"]:
                logger.error("‚ùå Pas de sprint_id disponible pour le test")
                return False
            
            # Soumettre une t√¢che
            submission_data = {
                "sprint_id": self.test_data["sprint_id"],
                "user_pseudonym": f"TestUser_{datetime.now().strftime('%H%M%S')}",
                "task_title": "API Endpoints Implementation",
                "solution": {
                    "github_repo": "https://github.com/testuser/ecommerce-api",
                    "live_demo": "https://test-api.herokuapp.com",
                    "documentation": "README.md complet avec instructions",
                    "tests_coverage": 85
                },
                "description": "Impl√©mentation compl√®te de l'API avec authentification JWT",
                "files": ["main.py", "models.py", "routes.py", "tests.py"]
            }
            
            submission_id = await self.db_service.submit_task(submission_data)
            if submission_id:
                self.test_data["submission_id"] = submission_id
                logger.info(f"‚úÖ T√¢che soumise avec l'ID: {submission_id}")
                return True
            else:
                logger.error("‚ùå √âchec de la soumission de t√¢che")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur dans les tests de soumission: {e}")
            return False
    
    async def test_feedback_operations(self):
        """Tester les op√©rations de feedback"""
        logger.info("\nüß™ Test des op√©rations de feedback...")
        
        try:
            if not self.test_data["sprint_id"]:
                logger.error("‚ùå Pas de sprint_id disponible pour le test")
                return False
            
            # Ajouter un feedback
            feedback_data = {
                "sprint_id": self.test_data["sprint_id"],
                "user_pseudonym": f"TestUser_{datetime.now().strftime('%H%M%S')}",
                "reviewer": "AI_Mentor_001",
                "feedback_type": "code_review",
                "rating": 4.2,
                "comments": {
                    "code_quality": "Excellent structure et lisibilit√©",
                    "architecture": "Bonnes pratiques respect√©es",
                    "testing": "Couverture de tests satisfaisante",
                    "documentation": "Documentation claire et compl√®te"
                },
                "suggestions": [
                    "Ajouter la validation d'entr√©e",
                    "Optimiser les requ√™tes de base de donn√©es",
                    "Impl√©menter le cache Redis"
                ],
                "overall_score": 85
            }
            
            feedback_id = await self.db_service.add_feedback(feedback_data)
            if feedback_id:
                self.test_data["feedback_id"] = feedback_id
                logger.info(f"‚úÖ Feedback ajout√© avec l'ID: {feedback_id}")
                
                # R√©cup√©rer les feedbacks du sprint
                feedbacks = await self.db_service.get_feedback_for_sprint(
                    self.test_data["sprint_id"]
                )
                logger.info(f"‚úÖ {len(feedbacks)} feedbacks trouv√©s pour le sprint")
                
                return True
            else:
                logger.error("‚ùå √âchec de l'ajout de feedback")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur dans les tests de feedback: {e}")
            return False
    
    async def test_scoring_operations(self):
        """Tester les op√©rations de scoring"""
        logger.info("\nüß™ Test des op√©rations de scoring...")
        
        try:
            user_pseudonym = f"TestUser_{datetime.now().strftime('%H%M%S')}"
            
            # Mettre √† jour le score
            score_data = {
                "sprint_id": self.test_data["sprint_id"],
                "score": 85.5,
                "breakdown": {
                    "code_quality": 90,
                    "collaboration": 80,
                    "innovation": 85,
                    "delivery": 87
                },
                "status": "completed",
                "mentor_feedback": "Excellent travail, continue comme √ßa !",
                "reveal_identity": True  # Score > 85%
            }
            
            score_success = await self.db_service.update_score(
                user_pseudonym,
                self.test_data["sprint_id"],
                score_data
            )
            
            if score_success:
                logger.info("‚úÖ Score mis √† jour avec succ√®s")
                
                # R√©cup√©rer les scores de l'utilisateur
                user_scores = await self.db_service.get_user_scores(user_pseudonym)
                logger.info(f"‚úÖ {len(user_scores)} scores trouv√©s pour l'utilisateur")
                
                # R√©cup√©rer les statistiques de l'utilisateur
                user_stats = await self.db_service.get_user_stats(user_pseudonym)
                logger.info(f"‚úÖ Stats utilisateur: {user_stats}")
                
                return True
            else:
                logger.error("‚ùå √âchec de la mise √† jour du score")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur dans les tests de scoring: {e}")
            return False
    
    async def test_database_connectivity(self):
        """Tester la connectivit√© de base"""
        logger.info("\nüß™ Test de connectivit√© de base...")
        
        try:
            db = get_database()
            
            # Test ping
            db.command("ping")
            logger.info("‚úÖ Ping MongoDB r√©ussi")
            
            # Lister les collections
            collections = db.list_collection_names()
            logger.info(f"‚úÖ Collections disponibles: {collections}")
            
            # Test d'√©criture/lecture simple
            test_doc = {"test": True, "timestamp": datetime.utcnow()}
            result = db.test_collection.insert_one(test_doc)
            logger.info(f"‚úÖ Test d'√©criture r√©ussi: {result.inserted_id}")
            
            # Lire le document
            retrieved = db.test_collection.find_one({"_id": result.inserted_id})
            if retrieved:
                logger.info("‚úÖ Test de lecture r√©ussi")
                
                # Nettoyer
                db.test_collection.delete_one({"_id": result.inserted_id})
                logger.info("‚úÖ Nettoyage effectu√©")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur de connectivit√©: {e}")
            return False
    
    async def cleanup(self):
        """Nettoyer les donn√©es de test"""
        logger.info("\nüßπ Nettoyage des donn√©es de test...")
        
        try:
            db = get_database()
            
            # Supprimer les donn√©es de test (optionnel en d√©veloppement)
            if self.test_data["user_id"]:
                db.users.delete_many({"pseudonym": {"$regex": "^TestUser_"}})
                logger.info("‚úÖ Utilisateurs de test supprim√©s")
            
            if self.test_data["sprint_id"]:
                db.sprints.delete_many({"title": {"$regex": "^Test"}})
                logger.info("‚úÖ Sprints de test supprim√©s")
            
            # Supprimer les autres collections de test
            db.submissions.delete_many({"user_pseudonym": {"$regex": "^TestUser_"}})
            db.feedback.delete_many({"user_pseudonym": {"$regex": "^TestUser_"}})
            db.scores.delete_many({"user_pseudonym": {"$regex": "^TestUser_"}})
            
            logger.info("‚úÖ Nettoyage termin√©")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du nettoyage: {e}")
    
    async def run_all_tests(self):
        """Ex√©cuter tous les tests"""
        logger.info("üß™ D√âBUT DES TESTS DE BASE DE DONN√âES BREAKIN DIRECT")
        logger.info("=" * 60)
        
        test_results = []
        
        # Initialisation
        if not await self.setup():
            logger.error("‚ùå √âchec de l'initialisation - Arr√™t des tests")
            return False
        
        # Tests individuels
        tests = [
            ("Connectivit√©", self.test_database_connectivity),
            ("Op√©rations Utilisateur", self.test_user_operations),
            ("Op√©rations Sprint", self.test_sprint_operations),
            ("Op√©rations Soumission", self.test_submission_operations),
            ("Op√©rations Feedback", self.test_feedback_operations),
            ("Op√©rations Scoring", self.test_scoring_operations),
        ]
        
        for test_name, test_func in tests:
            try:
                result = await test_func()
                test_results.append((test_name, result))
                if result:
                    logger.info(f"‚úÖ {test_name}: R√âUSSI")
                else:
                    logger.error(f"‚ùå {test_name}: √âCHEC")
            except Exception as e:
                logger.error(f"‚ùå {test_name}: ERREUR - {e}")
                test_results.append((test_name, False))
        
        # Nettoyage
        await self.cleanup()
        
        # R√©sum√© final
        logger.info("\n" + "=" * 60)
        logger.info("üìä R√âSUM√â DES TESTS")
        logger.info("=" * 60)
        
        passed = sum(1 for _, result in test_results if result)
        total = len(test_results)
        
        for test_name, result in test_results:
            status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHEC"
            logger.info(f"{test_name:<25} : {status}")
        
        logger.info("-" * 60)
        logger.info(f"Tests r√©ussis: {passed}/{total}")
        logger.info(f"Taux de r√©ussite: {(passed/total)*100:.1f}%")
        
        if passed == total:
            logger.info("üéâ TOUS LES TESTS ONT R√âUSSI ! Base de donn√©es pr√™te pour le d√©veloppement.")
        else:
            logger.warning(f"‚ö†Ô∏è {total-passed} test(s) ont √©chou√©. V√©rifiez la configuration.")
        
        return passed == total


async def main():
    """Fonction principale"""
    tester = DatabaseTester()
    
    try:
        success = await tester.run_all_tests()
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        logger.info("\nüõë Tests interrompus par l'utilisateur")
        sys.exit(1)
        
    except Exception as e:
        logger.error(f"‚ùå Erreur inattendue: {e}")
        sys.exit(1)
        
    finally:
        # Fermer la connexion
        close_mongodb_connection()
        logger.info("üîê Connexion MongoDB ferm√©e")


if __name__ == "__main__":
    # Ex√©cuter les tests
    asyncio.run(main())